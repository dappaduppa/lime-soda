<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">


<!-- Page 383 -->
<svg x="0" y="0" width="909" height="1286" viewBox="0 0 909 1286" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
style="display: block;margin-left: auto;margin-right: auto;">
<defs>

<style type="text/css"><![CDATA[


.s1_383{
font-size: 30.81px;
font-family: LiberationSerif-Bold_b;
fill: #8E0012;
}
.s2_383{
font-size: 22.01px;
font-family: LiberationSerif_e;
fill: #000000;
}
.s3_383{
font-size: 17.60px;
font-family: LiberationMono_1q;
fill: #000000;
}
.s4_383{
font-size: 22.01px;
font-family: LiberationSerif_e;
fill: #8E0012;
}
.s5_383{
font-size: 13.20px;
font-family: LiberationMono-Bold_1w;
fill: #006699;
}
.s6_383{
font-size: 13.20px;
font-family: LiberationMono_1q;
fill: #000000;
}
.s7_383{
font-size: 13.20px;
font-family: LiberationMono_1q;
fill: #000088;
}
.s8_383{
font-size: 13.20px;
font-family: LiberationMono_1q;
fill: #FF6600;
}

]]></style>

</defs>
<path d="M0,0
L0,1286
L909,1286
L909,0 Z " 
fill="#FFFFFF" stroke="none" />
<text 
x="55" 
y="81" 
dx="0,0,0,0,0,0,-1.7,0" 
class="s1_383"
>GROUP BY</text>

<text 
x="55" 
y="122" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.8,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>Another common SQL operation is</text>

<text 
x="369" 
y="122" 
dx="0,0,0,0,0,0,6.1,0" 
class="s3_383"
>GROUP BY</text>

<text 
x="454" 
y="122" 
class="s2_383"
>, which groups together rows with identical</text>

<text 
x="55" 
y="151" 
class="s2_383"
>values in specified columns and produces aggregate values like</text>

<text 
x="617" 
y="151" 
class="s3_383"
>MIN</text>

<text 
x="654" 
y="151" 
class="s2_383"
>and</text>

<text 
x="691" 
y="151" 
class="s3_383"
>MAX</text>

<text 
x="728" 
y="151" 
class="s2_383"
>and</text>

<text 
x="766" 
y="151" 
class="s3_383"
>COUNT</text>

<text 
x="55" 
y="181" 
class="s2_383"
>and</text>

<text 
x="92" 
y="181" 
class="s3_383"
>SUM</text>

<text 
x="123" 
y="181" 
class="s2_383"
>. (This should remind you of the</text>

<text 
x="413" 
y="181" 
class="s3_383"
>group_by</text>

<text 
x="503" 
y="181" 
class="s2_383"
>function from</text>

<text 
x="630" 
y="181" 
class="s4_383"
>“Manipulating Data”</text>

<text 
x="815" 
y="181" 
class="s2_383"
>.)</text>

<text 
x="55" 
y="222" 
class="s2_383"
>For example, you might want to find the number of users and the smallest</text>

<text 
x="710" 
y="222" 
class="s3_383"
>user_id</text>

<text 
x="789" 
y="222" 
class="s2_383"
>for</text>

<text 
x="55" 
y="251" 
class="s2_383"
>each possible name length:</text>

<text 
x="76" 
y="297" 
dx="0,0,0,0,0,0,0,4.6,0,0,0,0,0" 
class="s5_383"
>SELECT LENGTH</text>

<text 
x="179" 
y="297" 
class="s6_383"
>(</text>

<text 
x="187" 
y="297" 
class="s7_383"
>name</text>

<text 
x="219" 
y="297" 
class="s6_383"
>)</text>

<text 
x="235" 
y="297" 
class="s5_383"
>as</text>

<text 
x="258" 
y="297" 
class="s7_383"
>name_length</text>

<text 
x="345" 
y="297" 
class="s6_383"
>,</text>

<text 
x="84" 
y="312" 
class="s5_383"
>MIN</text>

<text 
x="108" 
y="312" 
class="s6_383"
>(</text>

<text 
x="116" 
y="312" 
class="s7_383"
>user_id</text>

<text 
x="171" 
y="312" 
class="s6_383"
>)</text>

<text 
x="187" 
y="312" 
class="s5_383"
>AS</text>

<text 
x="211" 
y="312" 
class="s7_383"
>min_user_id</text>

<text 
x="298" 
y="312" 
class="s6_383"
>,</text>

<text 
x="84" 
y="327" 
class="s5_383"
>COUNT</text>

<text 
x="124" 
y="327" 
class="s6_383"
>(*)</text>

<text 
x="156" 
y="327" 
class="s5_383"
>AS</text>

<text 
x="179" 
y="327" 
class="s7_383"
>num_users</text>

<text 
x="76" 
y="343" 
class="s5_383"
>FROM</text>

<text 
x="116" 
y="343" 
class="s7_383"
>users</text>

<text 
x="76" 
y="358" 
dx="0,0,0,0,0,0,4.6,0,0,4.6,0,0,0,0,0" 
class="s5_383"
>GROUP BY LENGTH</text>

<text 
x="195" 
y="358" 
class="s6_383"
>(</text>

<text 
x="203" 
y="358" 
class="s7_383"
>name</text>

<text 
x="235" 
y="358" 
class="s6_383"
>);</text>

<text 
x="55" 
y="411" 
class="s2_383"
>Every field we</text>

<text 
x="189" 
y="411" 
class="s3_383"
>SELECT</text>

<text 
x="258" 
y="411" 
class="s2_383"
>needs to be either in the</text>

<text 
x="473" 
y="411" 
dx="0,0,0,0,0,0,6.1,0" 
class="s3_383"
>GROUP BY</text>

<text 
x="563" 
y="411" 
class="s2_383"
>clause (which</text>

<text 
x="690" 
y="411" 
class="s3_383"
>name_length</text>

<text 
x="812" 
y="411" 
class="s2_383"
>is)</text>

<text 
x="55" 
y="441" 
class="s2_383"
>or an aggregate computation (which</text>

<text 
x="377" 
y="441" 
class="s3_383"
>min_user_id</text>

<text 
x="499" 
y="441" 
class="s2_383"
>and</text>

<text 
x="536" 
y="441" 
class="s3_383"
>num_users</text>

<text 
x="637" 
y="441" 
class="s2_383"
>are).</text>

<text 
x="55" 
y="481" 
dx="0,0,0,0,-0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>SQL also supports a</text>

<text 
x="237" 
y="481" 
class="s3_383"
>HAVING</text>

<text 
x="306" 
y="481" 
class="s2_383"
>clause that behaves similarly to a</text>

<text 
x="602" 
y="481" 
class="s3_383"
>WHERE</text>

<text 
x="661" 
y="481" 
class="s2_383"
>clause except that its</text>

<text 
x="55" 
y="511" 
class="s2_383"
>filter is applied to the aggregates (whereas a</text>

<text 
x="448" 
y="511" 
class="s3_383"
>WHERE</text>

<text 
x="506" 
y="511" 
class="s2_383"
>would filter out rows before</text>

<text 
x="55" 
y="541" 
class="s2_383"
>aggregation even took place).</text>

<text 
x="55" 
y="579" 
dx="0,-2.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>You might want to know the average number of friends for users whose names start with</text>

<text 
x="55" 
y="607" 
class="s2_383"
>specific letters but only see the results for letters whose corresponding average is greater</text>

<text 
x="55" 
y="634" 
dx="0,0,0,0,0,0,0,0,0,0,-2.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>than 1. (Yes, some of these examples are contrived.)</text>

<text 
x="76" 
y="679" 
class="s5_383"
>SELECT</text>

<text 
x="132" 
y="679" 
class="s7_383"
>SUBSTR</text>

<text 
x="179" 
y="679" 
class="s6_383"
>(</text>

<text 
x="187" 
y="679" 
class="s7_383"
>name</text>

<text 
x="219" 
y="679" 
class="s6_383"
>,</text>

<text 
x="235" 
y="679" 
class="s8_383"
>1</text>

<text 
x="242" 
y="679" 
class="s6_383"
>,</text>

<text 
x="258" 
y="679" 
class="s8_383"
>1</text>

<text 
x="266" 
y="679" 
class="s6_383"
>)</text>

<text 
x="282" 
y="679" 
class="s5_383"
>AS</text>

<text 
x="306" 
y="679" 
class="s7_383"
>first_letter</text>

<text 
x="401" 
y="679" 
class="s6_383"
>,</text>

<text 
x="84" 
y="695" 
class="s5_383"
>AVG</text>

<text 
x="108" 
y="695" 
class="s6_383"
>(</text>

<text 
x="116" 
y="695" 
class="s7_383"
>num_friends</text>

<text 
x="203" 
y="695" 
class="s6_383"
>)</text>

<text 
x="219" 
y="695" 
class="s5_383"
>AS</text>

<text 
x="242" 
y="695" 
class="s7_383"
>avg_num_friends</text>

<text 
x="76" 
y="710" 
class="s5_383"
>FROM</text>

<text 
x="116" 
y="710" 
class="s7_383"
>users</text>

<text 
x="76" 
y="726" 
dx="0,0,0,0,0,0,4.6,0" 
class="s5_383"
>GROUP BY</text>

<text 
x="148" 
y="726" 
class="s7_383"
>SUBSTR</text>

<text 
x="195" 
y="726" 
class="s6_383"
>(</text>

<text 
x="203" 
y="726" 
class="s7_383"
>name</text>

<text 
x="235" 
y="726" 
class="s6_383"
>,</text>

<text 
x="250" 
y="726" 
class="s8_383"
>1</text>

<text 
x="258" 
y="726" 
class="s6_383"
>,</text>

<text 
x="274" 
y="726" 
class="s8_383"
>1</text>

<text 
x="282" 
y="726" 
class="s6_383"
>)</text>

<text 
x="76" 
y="741" 
dx="0,0,0,0,0,0,0,4.6,0,0" 
class="s5_383"
>HAVING AVG</text>

<text 
x="156" 
y="741" 
class="s6_383"
>(</text>

<text 
x="163" 
y="741" 
class="s7_383"
>num_friends</text>

<text 
x="250" 
y="741" 
dx="0,0,4.6" 
class="s6_383"
>) &gt;</text>

<text 
x="282" 
y="741" 
class="s8_383"
>1</text>

<text 
x="290" 
y="741" 
class="s6_383"
>;</text>

<text 
x="55" 
y="794" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>(Functions for working with strings vary across SQL implementations; some databases</text>

<text 
x="55" 
y="821" 
class="s2_383"
>might instead use</text>

<text 
x="214" 
y="821" 
class="s3_383"
>SUBSTRING</text>

<text 
x="314" 
y="821" 
class="s2_383"
>or something else.)</text>

<text 
x="55" 
y="862" 
dx="0,-2.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0" 
class="s2_383"
>You can also compute overall aggregates. In that case, you leave off the</text>

<text 
x="690" 
y="862" 
dx="0,0,0,0,0,0,6.1,0" 
class="s3_383"
>GROUP BY</text>

<text 
x="774" 
y="862" 
class="s2_383"
>:</text>

<text 
x="76" 
y="909" 
dx="0,0,0,0,0,0,0,4.6,0,0" 
class="s5_383"
>SELECT SUM</text>

<text 
x="156" 
y="909" 
class="s6_383"
>(</text>

<text 
x="163" 
y="909" 
class="s7_383"
>user_id</text>

<text 
x="219" 
y="909" 
class="s6_383"
>)</text>

<text 
x="235" 
y="909" 
class="s5_383"
>as</text>

<text 
x="258" 
y="909" 
class="s7_383"
>user_id_sum</text>

<text 
x="76" 
y="925" 
class="s5_383"
>FROM</text>

<text 
x="116" 
y="925" 
class="s7_383"
>users</text>

<text 
x="76" 
y="940" 
class="s5_383"
>WHERE</text>

<text 
x="124" 
y="940" 
class="s7_383"
>user_id</text>

<text 
x="187" 
y="940" 
class="s6_383"
>&gt;</text>

<text 
x="203" 
y="940" 
class="s8_383"
>1</text>

<text 
x="211" 
y="940" 
class="s6_383"
>;</text>

<text 
x="55" 
y="993" 
dx="0,-1.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>To add this functionality to NotQuiteABase</text>

<text 
x="444" 
y="993" 
class="s3_383"
>Table</text>

<text 
x="496" 
y="993" 
class="s2_383"
>s, we’ll add a</text>

<text 
x="619" 
y="993" 
class="s3_383"
>group_by()</text>

<text 
x="730" 
y="993" 
class="s2_383"
>method. It</text>

<text 
x="55" 
y="1023" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>takes the names of the columns you want to group by, a dictionary of the aggregation</text>

<text 
x="55" 
y="1050" 
class="s2_383"
>functions you want to run over each group, and an optional predicate</text>

<text 
x="666" 
y="1050" 
class="s3_383"
>having</text>

<text 
x="734" 
y="1050" 
class="s2_383"
>that operates</text>

<text 
x="55" 
y="1080" 
class="s2_383"
>on multiple rows.</text>

<text 
x="55" 
y="1118" 
class="s2_383"
>Then it does the following steps:</text>

<text 
x="75" 
y="1156" 
dx="0,0,0,6.6,0,0,0,0,0,0,0,0" 
class="s2_383"
>1. Creates a</text>

<text 
x="191" 
y="1156" 
class="s3_383"
>defaultdict</text>

<text 
x="312" 
y="1156" 
class="s2_383"
>to map</text>

<text 
x="378" 
y="1156" 
class="s3_383"
>tuple</text>

<text 
x="431" 
y="1156" 
class="s2_383"
>s (of the group-by-values) to rows (containing</text>

<text 
x="104" 
y="1181" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_383"
>the group-by-values). Recall that you can’t use lists as</text>

<text 
x="586" 
y="1181" 
class="s3_383"
>dict</text>

<text 
x="634" 
y="1181" 
class="s2_383"
>keys; you have to use</text>

<text 
x="104" 
y="1206" 
class="s2_383"
>tuples.</text>



<!-- Any embedded fonts defined here -->
<style type="text/css" ><![CDATA[

@font-face {
	font-family: LiberationMono-Bold_1w;
	src: url("fonts/LiberationMono-Bold_1w.woff") format("woff");
}

@font-face {
	font-family: LiberationMono_1q;
	src: url("fonts/LiberationMono_1q.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif-Bold_b;
	src: url("fonts/LiberationSerif-Bold_b.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif_e;
	src: url("fonts/LiberationSerif_e.woff") format("woff");
}

]]></style>

</svg>
