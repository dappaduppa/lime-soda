<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">


<!-- Page 399 -->
<svg x="0" y="0" width="909" height="1286" viewBox="0 0 909 1286" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
style="display: block;margin-left: auto;margin-right: auto;">
<defs>

<style type="text/css"><![CDATA[

.g1_399{
fill: #BEBEBE;
}
.g2_399{
stroke: #000000;
stroke-width: 1.0996486;
stroke-linecap: square;
stroke-linejoin: miter;
}

.s1_399{
font-size: 30.81px;
font-family: LiberationSerif-Bold_b;
fill: #8E0012;
}
.s2_399{
font-size: 22.01px;
font-family: LiberationSerif_e;
fill: #000000;
}
.s3_399{
font-size: 22.01px;
font-family: LiberationSerif-Bold_b;
fill: #737373;
}
.s4_399{
font-size: 16.50px;
font-family: LiberationSerif_e;
fill: #000000;
}
.s5_399{
font-size: 16.50px;
font-family: LiberationSerif-Italic_l;
fill: #000000;
}

]]></style>

</defs>
<path d="M0,0
L0,1286
L909,1286
L909,0 Z " 
fill="#FFFFFF" stroke="none" />
<path fill-rule="evenodd" d="M93.5,315.8l722.5,0c3,0,5.5,2.4,5.5,5.5l0,77c0,3,-2.5,5.5,-5.5,5.5l-722.5,0c-3,0,-5.5,-2.5,-5.5,-5.5l0,-77c0,-3.1,2.5,-5.5,5.5,-5.5m0,1.1l722.5,0c2.4,0,4.4,1.9,4.4,4.4l0,77c0,2.4,-2,4.4,-4.4,4.4l-722.5,0c-2.4,0,-4.4,-2,-4.4,-4.4l0,-77c0,-2.5,2,-4.4,4.4,-4.4Z" class="g1_399" />
<text 
x="55" 
y="81" 
class="s1_399"
>Why MapReduce?</text>

<text 
x="55" 
y="122" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_399"
>As mentioned earlier, the primary benefit of MapReduce is that it allows us to distribute</text>

<text 
x="55" 
y="149" 
class="s2_399"
>computations by moving the processing to the data. Imagine we want to word-count</text>

<text 
x="55" 
y="177" 
class="s2_399"
>across billions of documents.</text>

<text 
x="55" 
y="215" 
class="s2_399"
>Our original (non-MapReduce) approach requires the machine doing the processing to</text>

<text 
x="55" 
y="243" 
class="s2_399"
>have access to every document. This means that the documents all need to either live on</text>

<text 
x="55" 
y="270" 
class="s2_399"
>that machine or else be transferred to it during processing. More important, it means that</text>

<text 
x="55" 
y="298" 
class="s2_399"
>the machine can only process one document at a time.</text>

<text 
x="421" 
y="341" 
dx="0,1.1,1.1,1.1" 
class="s3_399"
>NOTE</text>

<text 
x="97" 
y="370" 
class="s4_399"
>Possibly it can process up to a few at a time if it has multiple cores and if the code is rewritten to take</text>

<text 
x="97" 
y="390" 
class="s4_399"
>advantage of them. But even so, all the documents still have to</text>

<text 
x="515" 
y="390" 
class="s5_399"
>get to</text>

<text 
x="556" 
y="390" 
class="s4_399"
>that machine.</text>

<text 
x="55" 
y="435" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.9,0,0,0,0,0,0" 
class="s2_399"
>Imagine now that our billions of documents are scattered across 100 machines. With the</text>

<text 
x="55" 
y="463" 
class="s2_399"
>right infrastructure (and glossing over some of the details), we can do the following:</text>

<path d="M61.6,490.7l6.6,0l0,6.6l-6.6,0l0,-6.6Z" class="g2_399" />
<text 
x="82" 
y="500" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0,0" 
class="s2_399"
>Have each machine run the mapper on its documents, producing lots of (key, value)</text>

<text 
x="82" 
y="525" 
class="s2_399"
>pairs.</text>

<path d="M61.6,563.3l6.6,0l0,6.6l-6.6,0l0,-6.6Z" class="g2_399" />
<text 
x="82" 
y="573" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_399"
>Distribute those (key, value) pairs to a number of “reducing” machines, making sure</text>

<text 
x="82" 
y="598" 
class="s2_399"
>that the pairs corresponding to any given key all end up on the same machine.</text>

<path d="M61.6,636l6.6,0l0,6.6l-6.6,0l0,-6.6Z" class="g2_399" />
<text 
x="82" 
y="645" 
class="s2_399"
>Have each reducing machine group the pairs by key and then run the reducer on each</text>

<text 
x="82" 
y="671" 
class="s2_399"
>set of values.</text>

<path d="M61.6,708.6l6.6,0l0,6.6l-6.6,0l0,-6.6Z" class="g2_399" />
<text 
x="82" 
y="718" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.2" 
class="s2_399"
>Return each (key, output) pair.</text>

<text 
x="55" 
y="766" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_399"
>What is amazing about this is that it scales horizontally. If we double the number of</text>

<text 
x="55" 
y="794" 
class="s2_399"
>machines, then (ignoring certain fixed-costs of running a MapReduce system) our</text>

<text 
x="55" 
y="821" 
class="s2_399"
>computation should run approximately twice as fast. Each mapper machine will only need</text>

<text 
x="55" 
y="849" 
class="s2_399"
>to do half as much work, and (assuming there are enough distinct keys to further distribute</text>

<text 
x="55" 
y="876" 
class="s2_399"
>the reducer work) the same is true for the reducer machines.</text>



<!-- Any embedded fonts defined here -->
<style type="text/css" ><![CDATA[

@font-face {
	font-family: LiberationSerif-Italic_l;
	src: url("fonts/LiberationSerif-Italic_l.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif-Bold_b;
	src: url("fonts/LiberationSerif-Bold_b.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif_e;
	src: url("fonts/LiberationSerif_e.woff") format("woff");
}

]]></style>

</svg>
