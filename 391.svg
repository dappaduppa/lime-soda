<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">


<!-- Page 391 -->
<svg x="0" y="0" width="909" height="1286" viewBox="0 0 909 1286" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
style="display: block;margin-left: auto;margin-right: auto;">
<defs>

<style type="text/css"><![CDATA[


.s1_391{
font-size: 30.81px;
font-family: LiberationSerif-Bold_b;
fill: #8E0012;
}
.s2_391{
font-size: 22.01px;
font-family: LiberationSerif_e;
fill: #000000;
}
.s3_391{
font-size: 17.60px;
font-family: LiberationMono_1q;
fill: #000000;
}

]]></style>

</defs>
<path d="M0,0
L0,1286
L909,1286
L909,0 Z " 
fill="#FFFFFF" stroke="none" />
<text 
x="55" 
y="81" 
class="s1_391"
>Indexes</text>

<text 
x="55" 
y="122" 
dx="0,-1.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0,0,0" 
class="s2_391"
>To find rows containing a specific value (say, where</text>

<text 
x="518" 
y="122" 
class="s3_391"
>name</text>

<text 
x="566" 
y="122" 
class="s2_391"
>is “Hero”), NotQuiteABase has</text>

<text 
x="55" 
y="151" 
class="s2_391"
>to inspect every row in the table. If the table has a lot of rows, this can take a very long</text>

<text 
x="55" 
y="179" 
class="s2_391"
>time.</text>

<text 
x="55" 
y="217" 
dx="0,0,0,0,0,0,0,0,0,-1.4,0,0,0,0" 
class="s2_391"
>Similarly, our</text>

<text 
x="181" 
y="217" 
class="s3_391"
>join</text>

<text 
x="228" 
y="217" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_391"
>algorithm is extremely inefficient. For each row in the left table, it</text>

<text 
x="55" 
y="247" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.2,0,0,0,0,0,0,0,0,0,0,0,-0.9,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_391"
>inspects every row in the right table to see if it’s a match. With two large tables this could</text>

<text 
x="55" 
y="275" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.2" 
class="s2_391"
>take approximately forever.</text>

<text 
x="55" 
y="313" 
class="s2_391"
>Also, you’d often like to apply constraints to some of your columns. For example, in your</text>

<text 
x="55" 
y="341" 
class="s3_391"
>users</text>

<text 
x="113" 
y="341" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_391"
>table you probably don’t want to allow two different users to have the same</text>

<text 
x="55" 
y="370" 
class="s3_391"
>user_id</text>

<text 
x="128" 
y="370" 
class="s2_391"
>.</text>

<text 
x="55" 
y="411" 
class="s2_391"
>Indexes solve all these problems. If the</text>

<text 
x="404" 
y="411" 
class="s3_391"
>user_interests</text>

<text 
x="557" 
y="411" 
class="s2_391"
>table had an index on</text>

<text 
x="750" 
y="411" 
class="s3_391"
>user_id</text>

<text 
x="824" 
y="411" 
class="s2_391"
>, a</text>

<text 
x="55" 
y="441" 
class="s2_391"
>smart</text>

<text 
x="109" 
y="441" 
class="s3_391"
>join</text>

<text 
x="157" 
y="441" 
class="s2_391"
>algorithm could find matches directly rather than scanning the whole table. If</text>

<text 
x="55" 
y="470" 
class="s2_391"
>the</text>

<text 
x="87" 
y="470" 
class="s3_391"
>users</text>

<text 
x="145" 
y="470" 
class="s2_391"
>table had a “unique” index on</text>

<text 
x="413" 
y="470" 
class="s3_391"
>user_id</text>

<text 
x="486" 
y="470" 
class="s2_391"
>, you’d get an error if you tried to insert a</text>

<text 
x="55" 
y="500" 
class="s2_391"
>duplicate.</text>

<text 
x="55" 
y="539" 
class="s2_391"
>Each table in a database can have one or more indexes, which allow you to quickly look</text>

<text 
x="55" 
y="566" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0" 
class="s2_391"
>up rows by key columns, efficiently join tables together, and enforce unique constraints on</text>

<text 
x="55" 
y="594" 
class="s2_391"
>columns or combinations of columns.</text>

<text 
x="55" 
y="632" 
class="s2_391"
>Designing and using indexes well is somewhat of a black art (which varies somewhat</text>

<text 
x="55" 
y="660" 
dx="0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1.2" 
class="s2_391"
>depending on the specific database), but if you end up doing a lot of database work it’s</text>

<text 
x="55" 
y="687" 
class="s2_391"
>worth learning about.</text>



<!-- Any embedded fonts defined here -->
<style type="text/css" ><![CDATA[

@font-face {
	font-family: LiberationMono_1q;
	src: url("fonts/LiberationMono_1q.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif-Bold_b;
	src: url("fonts/LiberationSerif-Bold_b.woff") format("woff");
}

@font-face {
	font-family: LiberationSerif_e;
	src: url("fonts/LiberationSerif_e.woff") format("woff");
}

]]></style>

</svg>
